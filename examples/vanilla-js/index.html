<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bouncy Ball - Comparing Web Animation Techniques - Vanilla JS</title>
  <style>
    ball {
      display: block;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: red;
    }
  </style>
</head>
<body>
  <ball></ball>
  <script>
    (function() {
      var maxHeight = 160, // px
          position = 160, // px
          velocity = 0, // px/second
          acceleration = -1200, // px/second^2
          then = Date.now(),
          now,
          delta;

      function update() {
        now = Date.now();
        delta = (now - then) / 1000; // seconds since last update

        if (position <= 0) {
          // There's some bug but otherwise I think this is good.
          //
          // Uh oh. We're off the map, so we need to back up a bit and figure
          // out at what point in time our position was zero. This shouldn't be
          // too bad because dt is discrete, so we don't need calculus. We just
          // use the old velocity and position to find at what t position is 0.
          //
          // We use that break our delta into delta1 and delta 2.
          //
          // Then we just calculate the intermediate velocity and position with delta1,
          // make velocity negative, and recalculate the final velocity and position with
          // delta2. That's the one we render, for this specific iteration.

          // Formula for a line, given a slope and a point:
          //   y - y1 = m(x - x1)
          //
          // Using position, velocity, and time:
          //   p - p1 = v(t - t1)
          //
          // Solving for t:
          //   t = (p - p1)/v + t1
          //
          //   timeAtp0 (ms) = (0 - position (px)) / (velocity (px/s) / (1s/1000ms)) + then (ms);
          //
          timeAtp0 = ((0 - position) / (velocity / 1000)) + then;
          delta1 = (timeAtp0 - then) / 1000;
          delta2 = (now - timeAtp0) / 1000;

          velocity = velocity + (acceleration * delta1);
          position = position + (velocity * delta1);

          velocity = -velocity;

          velocity = velocity + (acceleration * delta2);
          position = position + (velocity * delta2);

        } else {
          velocity = velocity + (acceleration * delta);
          position = position + (velocity * delta);
        }

        then = now;

        console.log('pos: ' + position + '; vel: ' + velocity + '; acc: ' + acceleration + '; delta: ' + delta);

        translatedPos = maxHeight - position;
        document.querySelector('ball').style.transform = 'translate3d(0px,' + translatedPos + 'px, 0px)';
        window.requestAnimationFrame(update);
      }

      update();
    })();
  </script>
</body>
</html>
